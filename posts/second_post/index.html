<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Consensus algorithms and blockchain governance | Jesus Ruiz</title><meta name=keywords content><meta name=description content="This article analyses the influence of consensus algorithms in the characteristics of governance models of Public-Permissioned blockchain networks, especifically when using Quorum, Besu and Fabric.
For many years before the blockchain, consensus algorithms have been used in distributed systems to achieve the desired technical properties of safety and liveness, while improving performance and reducing cost. However, with the advent of the blockchain technology, consensus algorithms are additionally important components of the governance model of the network infrastructure."><meta name=author content><link rel=canonical href=https://hesusruiz.github.io/posts/second_post/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://hesusruiz.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://hesusruiz.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hesusruiz.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://hesusruiz.github.io/apple-touch-icon.png><link rel=mask-icon href=https://hesusruiz.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Consensus algorithms and blockchain governance"><meta property="og:description" content="This article analyses the influence of consensus algorithms in the characteristics of governance models of Public-Permissioned blockchain networks, especifically when using Quorum, Besu and Fabric.
For many years before the blockchain, consensus algorithms have been used in distributed systems to achieve the desired technical properties of safety and liveness, while improving performance and reducing cost. However, with the advent of the blockchain technology, consensus algorithms are additionally important components of the governance model of the network infrastructure."><meta property="og:type" content="article"><meta property="og:url" content="https://hesusruiz.github.io/posts/second_post/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-08T17:58:38+02:00"><meta property="article:modified_time" content="2022-05-08T17:58:38+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Consensus algorithms and blockchain governance"><meta name=twitter:description content="This article analyses the influence of consensus algorithms in the characteristics of governance models of Public-Permissioned blockchain networks, especifically when using Quorum, Besu and Fabric.
For many years before the blockchain, consensus algorithms have been used in distributed systems to achieve the desired technical properties of safety and liveness, while improving performance and reducing cost. However, with the advent of the blockchain technology, consensus algorithms are additionally important components of the governance model of the network infrastructure."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hesusruiz.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Consensus algorithms and blockchain governance","item":"https://hesusruiz.github.io/posts/second_post/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Consensus algorithms and blockchain governance","name":"Consensus algorithms and blockchain governance","description":"This article analyses the influence of consensus algorithms in the characteristics of governance models of Public-Permissioned blockchain networks, especifically when using Quorum, Besu and Fabric.\nFor many years before the blockchain, consensus algorithms have been used in distributed systems to achieve the desired technical properties of safety and liveness, while improving performance and reducing cost. However, with the advent of the blockchain technology, consensus algorithms are additionally important components of the governance model of the network infrastructure.","keywords":[],"articleBody":"This article analyses the influence of consensus algorithms in the characteristics of governance models of Public-Permissioned blockchain networks, especifically when using Quorum, Besu and Fabric.\nFor many years before the blockchain, consensus algorithms have been used in distributed systems to achieve the desired technical properties of safety and liveness, while improving performance and reducing cost. However, with the advent of the blockchain technology, consensus algorithms are additionally important components of the governance model of the network infrastructure.\nSummary In order to maximise decentralisation, the Decentralised Governance Model of Public-Permissioned blockchain networks dictates that the nodes of the blockchain network should be geo-distributed, operated by different and independent entities and avoiding that any individual entity has a disproportionate amount of control over any part of the system, whether at the technical or the governance level.\nConsensys Quorum, Hyperledger Besu and Hyperledger Fabric are technologies used in some blockhain networks aiming at the Public-Permissioned model, like in EBSI or Alastria. They use different consensus algorithms:\n Quorum and Besu use QBFT, a Byzantine Fault Tolerant (BFT) protocol. Fabric uses RAFT, a Crash Fault Tolerant (CFT) protocol.  With respect to resilience, the types of faults that each type of algorithm can handle are different. While CFT protects only from crash faults (fail-stop), BFT assumes an extremely powerful adversary that can fully control at the same time 1/3 of the machines and also the message delivery schedule across the entire network.\nCFT protocols do not offer protection against malicious actors or arbitrary failures of nodes. It protects only against fail-stop errors, essentially when a process stops executing and does not send any further message to the rest of the network. With CFT, if a malicious actor controls a single node the whole network is compromised.\nBFT protocols are robust against malicious actors or arbitrary failures of nodes. If one node is compromised the safety of the network is not affected at all. The bad actor should take control of one third of the nodes and the whole network communications simultaneously in order to affect the safety of the network.\nThe additional protection of BFT implies that for fail-stop errors (non-malicious) CFT is cheaper and faster than BFT for the same level of resiliency (obviously this is because of the null protection of CFT against malicious actors).\nThe choice of consensus algorithm executed by the critical nodes in the network has not only technical implications, but more importantly, governance implications:\n With BFT the set of critical nodes can be operated by different Member States, maximising at the same time the decentralisation and the resilience of the network. With CFT the standard approach is that a single centralised entity operates all critical nodes, like in private consortium networks. This reduces the attack surface, but it still provides a lower protection against malicious actors and it is much more centralised than with BFT protocols.  Recommendation: if a Decentralised Governance Model is important, then it is recommended that only blockchain technology using BFT protocols is deployed at full scale. That means that full-scale deployment of Fabric in Public-Permissioned blockchain networks can not be performed until Fabric implements a BFT consensus algorithm, which is in its roadmap (though there is no planned date yet).\nBFT and CFT consensus algorithms Replication is a technique that has been used for many years to achieve fault tolerance and reliability.\nIn 1952 John von Neumann [1] and in 1956 Ed Moore and Claude Shannon [2] showed how reliable subsystems in general (von Neumann) and reliable relay circuits in particular (Moore-Shannon) can be built out of unreliable components. Also relevant is the 1960 paper of Paul Baran [3] on implementing reliable communications despite unreliable network nodes, which was influential in the early days of the ARPAnet.\nIn the beginning, work on reliability via replication was mainly focused on hardware techniques. It was not until the 70’s when software started to be used to achieve the desired reliability properties, especially in mission-critical systems.\nAt the beginning of the 70’s it became clear that computers were going to be flying commercial aircraft and NASA began funding research to figure out how to make them reliable enough for the task. An example was the SIFT (Software Implemented Fault Tolerance) project [4] which designed an ultra reliable computer for critical aircraft control applications that achieved fault tolerance by the replication of tasks among processing units.\nOne of the most notable results of the project was the formal description of two types of errors, described first in 1978 [5] and finally in 1982 [6] in the famous paper The Byzantine Generals Problem:\n CFT (Crash Fault Tolerant): where the process stops functioning. BFT (Byzantine Fault Tolerant): where the process continues to operate but performs one or more operations incorrectly in an arbitrary way, including malicious behaviour.  In the 90’s the paper The Part-Time Parliament [7] described Paxos, a consensus algorithm solving the CFT problem and later in that decade the paper Practical Byzantine Fault Tolerance [8] described a consensus algorithm solving the more general problem of reliability under byzantine failures.\nEven though BFT systems are much more resilient than CFT ones, in 40 years of distributed systems most commercial implementations have used only CFT consensus algorithms, like Paxos or Raft [9]. There are several reasons for this, most notably the additional cost of BFT in terms of resources, protocol complexity and performance.\nFor example, in a partially synchronous setting, BFT requires 3f + 1 replicas to tolerate f faults while CFT needs only 2f + 1 replicas for the same number of faults. In addition, the number of messages required in BFT grows quadratically with the number of nodes, while in CFT the growth is linear.\nOf course, the types of faults that each type of algorithm can handle are different. While CFT protects only from crash faults (fail-stop), BFT assumes an extremely powerful adversary that can fully control at the same time 1/3 of the machines and also the message delivery schedule across the entire network.\nMost distributed systems have been deployed and operated inside a single administrative domain (e.g., Amazon, Google, Facebook, etc.) and for the engineers operating those centrally managed distributed systems, a CFT consensus algorithm is “good enough”. The adversary model assumed by BFT is too strong for what they normally observe in practice. In this situation, the engineers prefer to focus their efforts in increasing the redundancy of the network among replicas or trying to make the processes fail silently instead of in a byzantine way (at least while they are not compromised by an attacker).\nThose engineers use additional mechanisms trying to protect against malicious actors and so avoid implementing a BFT consensus, like protecting the machines inside firewalls and implementing mechanisms for monitoring and intrusion detection. However, none of these efforts has been able to avoid completely byzantine failures in those infrastructures, as described in these reports (TODO). But until recently this did not change the overall panorama regarding the almost non-existent implementation of industrial BFT systems.\nBitcoin and new BFT consensus algorithms Until Bitcoin appeared, the main research and implementation efforts on consensus algorithms for distributed systems assumed that there was a single administrative entity operating the whole distributed system and that the objectives were to achieve the maximum reliability with the highest performance and with the minimum cost.\nBitcoin used a completely different approach. The designer(s) used a different set of optimization objectives: while trying to maximise safety, they designed a novel BFT consensus algorithm to enable many different anonymous entities to coordinate in the operation of the system, and surprisingly to all existing practitioners in traditional distributed systems performance was less important than decentralisation (a precise definition of the term decentralisation does not exist, but here it means that the system is operated collaboratively by more than one administrative entity). Bitcoin was the first practical distributed system where a BFT consensus algorithm was used not only to achieve safety but where it was also embedded in the governance of the infrastructure. Consequently, the consensus algorithm is radically different from any other one that was developed before.\nIn this setting, it was impossible to use a CFT consensus algorithm because in a permissionless network like Bitcoin there may be many attackers with full access to the system. None of the techniques that engineers were using before with “in-house” CFT distributed systems could be used to protect the Bitcoin system.\nSuddenly, the powerful adversary model assumed by BFT did not seem so unrealistic in this new setting. The additional problem that the designers of Bitcoin had to overcome is that almost all research on BFT before considered a permissioned setting, that is, all replicas are known among them.\nThis is another of the breakthroughs of Bitcoin: the new BFT consensus algorithm works with anonymous participants where they can come and go without anybody having to permission any of the nodes in the consensus set or even in the whole network.\nHowever, this anonymous nature of the participants, including the ones executing the consensus algorithm is at the core of the performance problems of those permissionless blockchain networks.\nIn contrast, Public-Permissioned networks useful for the real economy, require from participants strong digital identities linked to their real-world identities. These digital identities enable the usage of much more efficient BFT consensus algorithms where practitioners can apply more than 30 years of research in resilient distributed systems.\nHyperledger Fabric consensus algorithm As stated in the official documentation for Hyperledger Fabric [13]:\n One of the most important of the platform’s differentiators is its support for pluggable consensus protocols that enable the platform to be more effectively customised to fit particular use cases and trust models. For instance, when deployed within a single enterprise, or operated by a trusted authority, fully byzantine fault tolerant consensus might be considered unnecessary and an excessive drag on performance and throughput. In situations such as that, a crash fault-tolerant (CFT) consensus protocol might be more than adequate whereas, in a multi-party, decentralised use case, a more traditional byzantine fault tolerant (BFT) consensus protocol might be required.\n Hyperledger Fabric supports pluggable consensus protocols. However, the current version of Fabric (2.4) only supports CFT protocols with Raft as the recommended production choice. The inclusion of a BFT protocol is in the strategic roadmap, though there is no planned date yet.\nRaft is a CFT (Crash-Fault-Tolerant) consensus algorithm that provides strict transaction finality, but it is not Byzantine fault tolerant. The protocol tolerates technical faults, where the participants are assumed to be always honest, and the machines can not behave in arbitrary ways.\nIn other words, if an attacker compromises just one of the consensus nodes (called orderers in Hyperledger Fabric) then the whole network may be compromised. This contrasts with a BFT (Byzantine Fault Tolerant) consensus algorithm where the network is resilient to more than one byzantine failure (at most one third of the number of consensus nodes).\nAnother way to look at this is that in a network where each consensus node is operated by a different entity, with a CFT algorithm just one operator can compromise the safety of the whole network. With a BFT algorithm there must be at least one third of the entities agreeing to attack the network. With BFT, increasing the number of entities running the consensus nodes increases arbitrarily the resilience of the network against malicious actors.\nThe Raft protocol is suitable for environments which:\n Are properly isolated from external attackers (e.g., an intranet isolated via firewalls from the external world), All the consensus nodes are operated by a single administrative domain (that is, a single entity). There is an extremely high level of trust among the participants in the network, especially with respect to the entity operating the consensus nodes.  In other words, even though the current version of Hyperledger Fabric is suitable for implementing decentralised use cases (decentralised at the application level), the governance of the underlying infrastructure tends to be centralised, requiring a high level of trust with respect to the entity operating the consensus nodes.\nThis may change in a future version of Hyperledger Fabric, but for the moment it is a serious limitation for the implementation of Public-Permissioned networks, where one of the critical properties is the decentralised nature of the governance model for the infrastructure.\nConsensus algorithms in Public-Permissioned blockchain networks With regards to resiliency, a Public-Permissioned blockchain network shares many of the properties of permissionless networks like Bitcoin or Ethereum. Even though it is permissioned, the decentralised governance model implies that nodes may deviate arbitrarily from the protocol for any reason.\nThey may be broken (e.g., misconfigured, compromised, malfunctioning, or badly programmed) or may just be optimising for an unknown utility function that differs from the utility function used by rational nodes — for instance, ascribing value to harm inflicted on the system or its users.\nThat means that in Public-Permissioned blockchain networks we must make the same assumptions about adversarial behaviours as in permissionless networks, to achieve the required safety and liveness properties.\nHowever, not all BFT consensus algorithms are equally suitable, as there are several other characteristics, apart from reliability, that are important. In the research literature there are several surveys and detailed analyses of the different types of consensus algorithms for blockchain networks and their properties. See for example [3], [1] or even for specialized fields like IoT [2].\nIn this document we will focus only on the properties of blockchain consensus algorithms which are most suitable for the type of use cases that will be typically implemented in Public-Permissioned networks.\n","wordCount":"2254","inLanguage":"en","datePublished":"2022-05-08T17:58:38+02:00","dateModified":"2022-05-08T17:58:38+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://hesusruiz.github.io/posts/second_post/"},"publisher":{"@type":"Organization","name":"Jesus Ruiz","logo":{"@type":"ImageObject","url":"https://hesusruiz.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hesusruiz.github.io/ accesskey=h title="Jesus Ruiz (Alt + H)">Jesus Ruiz</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hesusruiz.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://hesusruiz.github.io/posts/>Posts</a></div><h1 class=post-title>Consensus algorithms and blockchain governance</h1><div class=post-meta><span title="2022-05-08 17:58:38 +0200 +0200">May 8, 2022</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#summary aria-label=Summary>Summary</a></li><li><a href=#bft-and-cft-consensus-algorithms aria-label="BFT and CFT consensus algorithms">BFT and CFT consensus algorithms</a></li><li><a href=#bitcoin-and-new-bft-consensus-algorithms aria-label="Bitcoin and new BFT consensus algorithms">Bitcoin and new BFT consensus algorithms</a></li><li><a href=#hyperledger-fabric-consensus-algorithm aria-label="Hyperledger Fabric consensus algorithm">Hyperledger Fabric consensus algorithm</a></li><li><a href=#consensus-algorithms-in-public-permissioned-blockchain-networks aria-label="Consensus algorithms in Public-Permissioned blockchain networks">Consensus algorithms in Public-Permissioned blockchain networks</a></li></ul></div></details></div><div class=post-content><p>This article analyses the influence of consensus algorithms in the characteristics of governance models of Public-Permissioned blockchain networks, especifically when using Quorum, Besu and Fabric.</p><p>For many years before the blockchain, consensus algorithms have been used in distributed systems to achieve the desired technical properties of safety and liveness, while improving performance and reducing cost. However, with the advent of the blockchain technology, consensus algorithms are additionally important components of the governance model of the network infrastructure.</p><h1 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h1><p>In order to maximise decentralisation, the Decentralised Governance Model of Public-Permissioned blockchain networks dictates that the nodes of the blockchain network should be geo-distributed, operated by different and independent entities and avoiding that any individual entity has a disproportionate amount of control over any part of the system, whether at the technical or the governance level.</p><p>Consensys Quorum, Hyperledger Besu and Hyperledger Fabric are technologies used in some blockhain networks aiming at the Public-Permissioned model, like in EBSI or Alastria. They use different consensus algorithms:</p><ul><li>Quorum and Besu use QBFT, a Byzantine Fault Tolerant (BFT) protocol.</li><li>Fabric uses RAFT, a Crash Fault Tolerant (CFT) protocol.</li></ul><p>With respect to resilience, the types of faults that each type of algorithm can handle are different. <strong>While CFT protects only from crash faults (fail-stop), BFT assumes an extremely powerful adversary that can fully control at the same time 1/3 of the machines and also the message delivery schedule across the entire network</strong>.</p><p>CFT protocols do not offer protection against malicious actors or arbitrary failures of nodes. It protects only against fail-stop errors, essentially when a process stops executing and does not send any further message to the rest of the network. With CFT, if a malicious actor controls a single node the whole network is compromised.</p><p>BFT protocols are robust against malicious actors or arbitrary failures of nodes. If one node is compromised the safety of the network is not affected at all. The bad actor should take control of one third of the nodes and the whole network communications simultaneously in order to affect the safety of the network.</p><p>The additional protection of BFT implies that for fail-stop errors (non-malicious) CFT is cheaper and faster than BFT for the same level of resiliency (obviously this is because of the null protection of CFT against malicious actors).</p><p>The choice of consensus algorithm executed by the critical nodes in the network has not only technical implications, but more importantly, governance implications:</p><ul><li>With BFT the set of critical nodes can be operated by different Member States, maximising at the same time the decentralisation and the resilience of the network.</li><li>With CFT the standard approach is that a single centralised entity operates all critical nodes, like in private consortium networks. This reduces the attack surface, but it still provides a lower protection against malicious actors and it is much more centralised than with BFT protocols.</li></ul><p>Recommendation: if a Decentralised Governance Model is important, then it is recommended that only blockchain technology using BFT protocols is deployed at full scale. That means that full-scale deployment of Fabric in Public-Permissioned blockchain networks can not be performed until Fabric implements a BFT consensus algorithm, which is in its roadmap (though there is no planned date yet).</p><h1 id=bft-and-cft-consensus-algorithms>BFT and CFT consensus algorithms<a hidden class=anchor aria-hidden=true href=#bft-and-cft-consensus-algorithms>#</a></h1><p>Replication is a technique that has been used for many years to achieve fault tolerance and reliability.</p><p>In 1952 John von Neumann [1] and in 1956 Ed Moore and Claude Shannon [2] showed how reliable subsystems in general (von Neumann) and reliable relay circuits in particular (Moore-Shannon) can be built out of unreliable components. Also relevant is the 1960 paper of Paul Baran [3] on implementing reliable communications despite unreliable network nodes, which was influential in the early days of the ARPAnet.</p><p>In the beginning, work on reliability via replication was mainly focused on hardware techniques. It was not until the 70’s when software started to be used to achieve the desired reliability properties, especially in mission-critical systems.</p><p>At the beginning of the 70’s it became clear that computers were going to be flying commercial aircraft and NASA began funding research to figure out how to make them reliable enough for the task. An example was the SIFT (Software Implemented Fault Tolerance) project [4] which designed an ultra reliable computer for critical aircraft control applications that achieved fault tolerance by the replication of tasks among processing units.</p><p>One of the most notable results of the project was the formal description of two types of errors, described first in 1978 [5] and finally in 1982 [6] in the famous paper The Byzantine Generals Problem:</p><ul><li>CFT (Crash Fault Tolerant): where the process stops functioning.</li><li>BFT (Byzantine Fault Tolerant): where the process continues to operate but performs one or more operations incorrectly in an arbitrary way, including malicious behaviour.</li></ul><p>In the 90’s the paper The Part-Time Parliament [7] described Paxos, a consensus algorithm solving the CFT problem and later in that decade the paper Practical Byzantine Fault Tolerance [8] described a consensus algorithm solving the more general problem of reliability under byzantine failures.</p><p>Even though BFT systems are much more resilient than CFT ones, in 40 years of distributed systems most commercial implementations have used only CFT consensus algorithms, like Paxos or Raft [9]. There are several reasons for this, most notably the additional cost of BFT in terms of resources, protocol complexity and performance.</p><p>For example, in a partially synchronous setting, BFT requires 3f + 1 replicas to tolerate f faults while CFT needs only 2f + 1 replicas for the same number of faults. In addition, the number of messages required in BFT grows quadratically with the number of nodes, while in CFT the growth is linear.</p><p>Of course, the types of faults that each type of algorithm can handle are different. While CFT protects only from crash faults (fail-stop), BFT assumes an extremely powerful adversary that can fully control at the same time 1/3 of the machines and also the message delivery schedule across the entire network.</p><p>Most distributed systems have been deployed and operated inside a single administrative domain (e.g., Amazon, Google, Facebook, etc.) and for the engineers operating those centrally managed distributed systems, a CFT consensus algorithm is “good enough”. The adversary model assumed by BFT is too strong for what they normally observe in practice.
In this situation, the engineers prefer to focus their efforts in increasing the redundancy of the network among replicas or trying to make the processes fail silently instead of in a byzantine way (at least while they are not compromised by an attacker).</p><p>Those engineers use additional mechanisms trying to protect against malicious actors and so avoid implementing a BFT consensus, like protecting the machines inside firewalls and implementing mechanisms for monitoring and intrusion detection.
However, none of these efforts has been able to avoid completely byzantine failures in those infrastructures, as described in these reports (TODO). But until recently this did not change the overall panorama regarding the almost non-existent implementation of industrial BFT systems.</p><h1 id=bitcoin-and-new-bft-consensus-algorithms>Bitcoin and new BFT consensus algorithms<a hidden class=anchor aria-hidden=true href=#bitcoin-and-new-bft-consensus-algorithms>#</a></h1><p>Until Bitcoin appeared, the main research and implementation efforts on consensus algorithms for distributed systems assumed that there was a single administrative entity operating the whole distributed system and that the objectives were to achieve the maximum reliability with the highest performance and with the minimum cost.</p><p>Bitcoin used a completely different approach. The designer(s) used a different set of optimization objectives: while trying to maximise safety, they designed a novel BFT consensus algorithm to enable many different anonymous entities to coordinate in the operation of the system, and surprisingly to all existing practitioners in traditional distributed systems performance was less important than decentralisation (a precise definition of the term decentralisation does not exist, but here it means that the system is operated collaboratively by more than one administrative entity).
Bitcoin was the first practical distributed system where a BFT consensus algorithm was used not only to achieve safety but where it was also embedded in the governance of the infrastructure. Consequently, the consensus algorithm is radically different from any other one that was developed before.</p><p>In this setting, it was impossible to use a CFT consensus algorithm because in a permissionless network like Bitcoin there may be many attackers with full access to the system. None of the techniques that engineers were using before with “in-house” CFT distributed systems could be used to protect the Bitcoin system.</p><p>Suddenly, the powerful adversary model assumed by BFT did not seem so unrealistic in this new setting.
The additional problem that the designers of Bitcoin had to overcome is that almost all research on BFT before considered a permissioned setting, that is, all replicas are known among them.</p><p>This is another of the breakthroughs of Bitcoin: the new BFT consensus algorithm works with anonymous participants where they can come and go without anybody having to permission any of the nodes in the consensus set or even in the whole network.</p><p>However, this anonymous nature of the participants, including the ones executing the consensus algorithm is at the core of the performance problems of those permissionless blockchain networks.</p><p>In contrast, Public-Permissioned networks useful for the real economy, require from participants strong digital identities linked to their real-world identities. These digital identities enable the usage of much more efficient BFT consensus algorithms where practitioners can apply more than 30 years of research in resilient distributed systems.</p><h1 id=hyperledger-fabric-consensus-algorithm>Hyperledger Fabric consensus algorithm<a hidden class=anchor aria-hidden=true href=#hyperledger-fabric-consensus-algorithm>#</a></h1><p>As stated in the official documentation for Hyperledger Fabric [13]:</p><blockquote><p>One of the most important of the platform’s differentiators is its support for pluggable consensus protocols that enable the platform to be more effectively customised to fit particular use cases and trust models. For instance, when deployed within a single enterprise, or operated by a trusted authority, fully byzantine fault tolerant consensus might be considered unnecessary and an excessive drag on performance and throughput. In situations such as that, a crash fault-tolerant (CFT) consensus protocol might be more than adequate whereas, in a multi-party, decentralised use case, a more traditional byzantine fault tolerant (BFT) consensus protocol might be required.</p></blockquote><p>Hyperledger Fabric supports pluggable consensus protocols. However, the current version of Fabric (2.4) only supports CFT protocols with Raft as the recommended production choice. The inclusion of a BFT protocol is in the strategic roadmap, though there is no planned date yet.</p><p>Raft is a CFT (Crash-Fault-Tolerant) consensus algorithm that provides strict transaction finality, but it is not Byzantine fault tolerant. The protocol tolerates technical faults, where the participants are assumed to be always honest, and the machines can not behave in arbitrary ways.</p><p>In other words, if an attacker compromises just one of the consensus nodes (called orderers in Hyperledger Fabric) then the whole network may be compromised. This contrasts with a BFT (Byzantine Fault Tolerant) consensus algorithm where the network is resilient to more than one byzantine failure (at most one third of the number of consensus nodes).</p><p>Another way to look at this is that in a network where each consensus node is operated by a different entity, with a CFT algorithm just one operator can compromise the safety of the whole network. With a BFT algorithm there must be at least one third of the entities agreeing to attack the network. With BFT, increasing the number of entities running the consensus nodes increases arbitrarily the resilience of the network against malicious actors.</p><p>The Raft protocol is suitable for environments which:</p><ul><li>Are properly isolated from external attackers (e.g., an intranet isolated via firewalls from the external world),</li><li>All the consensus nodes are operated by a single administrative domain (that is, a single entity).</li><li>There is an extremely high level of trust among the participants in the network, especially with respect to the entity operating the consensus nodes.</li></ul><p>In other words, even though the current version of Hyperledger Fabric is suitable for implementing decentralised use cases (decentralised at the application level), the governance of the underlying infrastructure tends to be centralised, requiring a high level of trust with respect to the entity operating the consensus nodes.</p><p>This may change in a future version of Hyperledger Fabric, but for the moment it is a serious limitation for the implementation of Public-Permissioned networks, where one of the critical properties is the decentralised nature of the governance model for the infrastructure.</p><h1 id=consensus-algorithms-in-public-permissioned-blockchain-networks>Consensus algorithms in Public-Permissioned blockchain networks<a hidden class=anchor aria-hidden=true href=#consensus-algorithms-in-public-permissioned-blockchain-networks>#</a></h1><p>With regards to resiliency, a Public-Permissioned blockchain network shares many of the properties of permissionless networks like Bitcoin or Ethereum. Even though it is permissioned, the decentralised governance model implies that nodes may deviate arbitrarily from the protocol for any reason.</p><p>They may be broken (e.g., misconfigured, compromised, malfunctioning, or badly programmed) or may just be optimising for an unknown utility function that differs from the utility function used by rational nodes — for instance, ascribing value to harm inflicted on the system or its users.</p><p>That means that in Public-Permissioned blockchain networks we must make the same assumptions about adversarial behaviours as in permissionless networks, to achieve the required safety and liveness properties.</p><p>However, not all BFT consensus algorithms are equally suitable, as there are several other characteristics, apart from reliability, that are important. In the research literature there are several surveys and detailed analyses of the different types of consensus algorithms for blockchain networks and their properties. See for example [3], [1] or even for specialized fields like IoT [2].</p><p>In this document we will focus only on the properties of blockchain consensus algorithms which are most suitable for the type of use cases that will be typically implemented in Public-Permissioned networks.</p></div><footer class=post-footer><ul class=post-tags></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Consensus algorithms and blockchain governance on twitter" href="https://twitter.com/intent/tweet/?text=Consensus%20algorithms%20and%20blockchain%20governance&url=https%3a%2f%2fhesusruiz.github.io%2fposts%2fsecond_post%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Consensus algorithms and blockchain governance on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fhesusruiz.github.io%2fposts%2fsecond_post%2f&title=Consensus%20algorithms%20and%20blockchain%20governance&summary=Consensus%20algorithms%20and%20blockchain%20governance&source=https%3a%2f%2fhesusruiz.github.io%2fposts%2fsecond_post%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Consensus algorithms and blockchain governance on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhesusruiz.github.io%2fposts%2fsecond_post%2f&title=Consensus%20algorithms%20and%20blockchain%20governance"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Consensus algorithms and blockchain governance on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhesusruiz.github.io%2fposts%2fsecond_post%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Consensus algorithms and blockchain governance on whatsapp" href="https://api.whatsapp.com/send?text=Consensus%20algorithms%20and%20blockchain%20governance%20-%20https%3a%2f%2fhesusruiz.github.io%2fposts%2fsecond_post%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Consensus algorithms and blockchain governance on telegram" href="https://telegram.me/share/url?text=Consensus%20algorithms%20and%20blockchain%20governance&url=https%3a%2f%2fhesusruiz.github.io%2fposts%2fsecond_post%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://hesusruiz.github.io/>Jesus Ruiz</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>